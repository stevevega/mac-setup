{"uri":"file:///Users/vega/Code/huli/manager-web/src/vendor/google/protobuf/php/src/Google/Protobuf/Internal/SourceCodeInfo.php","root":{"kind":0,"name":"","children":[{"kind":512,"name":"Google\\Protobuf\\Internal","location":[4,0,4,35]},{"kind":1,"name":"GPBType","modifiers":4096,"location":[6,4,6,36],"associated":[{"kind":1,"name":"Google\\Protobuf\\Internal\\GPBType"}]},{"kind":1,"name":"GPBWire","modifiers":4096,"location":[7,4,7,36],"associated":[{"kind":1,"name":"Google\\Protobuf\\Internal\\GPBWire"}]},{"kind":1,"name":"RepeatedField","modifiers":4096,"location":[8,4,8,42],"associated":[{"kind":1,"name":"Google\\Protobuf\\Internal\\RepeatedField"}]},{"kind":1,"name":"InputStream","modifiers":4096,"location":[9,4,9,40],"associated":[{"kind":1,"name":"Google\\Protobuf\\Internal\\InputStream"}]},{"kind":1,"name":"GPBUtil","modifiers":4096,"location":[11,4,11,36],"associated":[{"kind":1,"name":"Google\\Protobuf\\Internal\\GPBUtil"}]},{"kind":1,"name":"Google\\Protobuf\\Internal\\SourceCodeInfo","location":[21,0,189,1],"associated":[{"kind":1,"name":"Google\\Protobuf\\Internal\\Message"}],"description":"<pre>\nEncapsulates information about the original source file from which a\nFileDescriptorProto was generated.\n</pre>\n\nProtobuf type <code>google.protobuf.SourceCodeInfo</code>","children":[{"kind":16,"name":"$location","modifiers":4,"location":[70,12,70,21],"scope":"Google\\Protobuf\\Internal\\SourceCodeInfo"},{"kind":16,"name":"$has_location","modifiers":4,"location":[71,12,71,33],"scope":"Google\\Protobuf\\Internal\\SourceCodeInfo"},{"kind":32,"name":"__construct","modifiers":1,"location":[73,4,76,5],"description":"<pre>\nA Location identifies a piece of source code in a .proto file which\ncorresponds to a particular definition.  This information is intended\nto be useful to IDEs, code indexers, documentation generators, and similar\ntools.\nFor example, say we have a file like:\nmessage Foo {\noptional string foo = 1;\n}\nLet's look at just the field definition:\noptional string foo = 1;\n^       ^^     ^^  ^  ^^^\na       bc     de  f  ghi\nWe have the following locations:\nspan   path               represents\n[a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\n[a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\n[c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\n[e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\n[g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\nNotes:\n- A location may refer to a repeated field itself (i.e. not to any\nparticular index within it).  This is used whenever a set of elements are\nlogically enclosed in a single code segment.  For example, an entire\nextend block (possibly containing multiple extension definitions) will\nhave an outer location whose path refers to the \"extensions\" repeated\nfield without an index.\n- Multiple locations may have the same path.  This happens when a single\nlogical declaration is spread out across multiple places.  The most\nobvious example is the \"extend\" block again -- there may be multiple\nextend blocks in the same scope, each of which will have the same path.\n- A location's span is not always a subset of its parent's span.  For\nexample, the \"extendee\" of an extension declaration appears at the\nbeginning of the \"extend\" block and is shared by all extensions within\nthe block.\n- Just because a location's span is a subset of some other location's span\ndoes not mean that it is a descendent.  For example, a \"group\" defines\nboth a type and a field in a single declaration.  Thus, the locations\ncorresponding to the type and field and their components will overlap.\n- Code which tries to interpret locations should probably be designed to\nignore those that it doesn't understand, as more types of locations could\nbe recorded in the future.\n</pre>\n\n<code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>","scope":"Google\\Protobuf\\Internal\\SourceCodeInfo"},{"kind":32,"name":"getLocation","modifiers":1,"location":[125,4,128,5],"description":"<pre>\nA Location identifies a piece of source code in a .proto file which\ncorresponds to a particular definition.  This information is intended\nto be useful to IDEs, code indexers, documentation generators, and similar\ntools.\nFor example, say we have a file like:\nmessage Foo {\noptional string foo = 1;\n}\nLet's look at just the field definition:\noptional string foo = 1;\n^       ^^     ^^  ^  ^^^\na       bc     de  f  ghi\nWe have the following locations:\nspan   path               represents\n[a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\n[a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\n[c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\n[e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\n[g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\nNotes:\n- A location may refer to a repeated field itself (i.e. not to any\nparticular index within it).  This is used whenever a set of elements are\nlogically enclosed in a single code segment.  For example, an entire\nextend block (possibly containing multiple extension definitions) will\nhave an outer location whose path refers to the \"extensions\" repeated\nfield without an index.\n- Multiple locations may have the same path.  This happens when a single\nlogical declaration is spread out across multiple places.  The most\nobvious example is the \"extend\" block again -- there may be multiple\nextend blocks in the same scope, each of which will have the same path.\n- A location's span is not always a subset of its parent's span.  For\nexample, the \"extendee\" of an extension declaration appears at the\nbeginning of the \"extend\" block and is shared by all extensions within\nthe block.\n- Just because a location's span is a subset of some other location's span\ndoes not mean that it is a descendent.  For example, a \"group\" defines\nboth a type and a field in a single declaration.  Thus, the locations\ncorresponding to the type and field and their components will overlap.\n- Code which tries to interpret locations should probably be designed to\nignore those that it doesn't understand, as more types of locations could\nbe recorded in the future.\n</pre>\n\n<code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>","scope":"Google\\Protobuf\\Internal\\SourceCodeInfo"},{"kind":32,"name":"setLocation","modifiers":1,"location":[177,4,182,5],"description":"<pre>\nA Location identifies a piece of source code in a .proto file which\ncorresponds to a particular definition.  This information is intended\nto be useful to IDEs, code indexers, documentation generators, and similar\ntools.\nFor example, say we have a file like:\nmessage Foo {\noptional string foo = 1;\n}\nLet's look at just the field definition:\noptional string foo = 1;\n^       ^^     ^^  ^  ^^^\na       bc     de  f  ghi\nWe have the following locations:\nspan   path               represents\n[a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\n[a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\n[c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\n[e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\n[g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\nNotes:\n- A location may refer to a repeated field itself (i.e. not to any\nparticular index within it).  This is used whenever a set of elements are\nlogically enclosed in a single code segment.  For example, an entire\nextend block (possibly containing multiple extension definitions) will\nhave an outer location whose path refers to the \"extensions\" repeated\nfield without an index.\n- Multiple locations may have the same path.  This happens when a single\nlogical declaration is spread out across multiple places.  The most\nobvious example is the \"extend\" block again -- there may be multiple\nextend blocks in the same scope, each of which will have the same path.\n- A location's span is not always a subset of its parent's span.  For\nexample, the \"extendee\" of an extension declaration appears at the\nbeginning of the \"extend\" block and is shared by all extensions within\nthe block.\n- Just because a location's span is a subset of some other location's span\ndoes not mean that it is a descendent.  For example, a \"group\" defines\nboth a type and a field in a single declaration.  Thus, the locations\ncorresponding to the type and field and their components will overlap.\n- Code which tries to interpret locations should probably be designed to\nignore those that it doesn't understand, as more types of locations could\nbe recorded in the future.\n</pre>\n\n<code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>","scope":"Google\\Protobuf\\Internal\\SourceCodeInfo","children":[{"kind":128,"name":"$var","location":[177,32,177,37],"scope":"setLocation"}]},{"kind":32,"name":"hasLocation","modifiers":1,"location":[184,4,187,5],"scope":"Google\\Protobuf\\Internal\\SourceCodeInfo"}]}]}}