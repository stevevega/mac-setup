{"uri":"file:///Users/vega/Code/huli/manager-web/src/vendor/zetacomponents/base/src/file.php","root":{"kind":0,"name":"","children":[{"kind":1,"name":"ezcBaseFile","location":[56,0,510,1],"description":"Provides a selection of static independent methods to provide functionality\nfor file and file system handling.\n\nThis example shows how to use the findRecursive method:\n<code>\n<?php\n// lists all the files under /etc (including subdirectories) that end in\n// .conf\n$confFiles = ezcBaseFile::findRecursive( \"/etc\", array( '@\\.conf$@' ) );\n\n// lists all autoload files in the components source tree and excludes the\n// ones in the autoload subdirectory. Statistics are returned in the $stats\n// variable which is passed by reference.\n$files = ezcBaseFile::findRecursive(\n\"/dat/dev/ezcomponents\",\narray( '@src/.*_autoload.php$@' ),\narray( '@/autoload/@' ),\n$stats\n);\n\n// lists all binaries in /bin except the ones starting with a \"g\"\n$data = ezcBaseFile::findRecursive( \"/bin\", array(), array( '@^/bin/g@' ) );\n?>\n</code>","children":[{"kind":32,"name":"findRecursiveCallback","modifiers":34,"location":[74,4,86,5],"description":"This is the callback used by findRecursive to collect data.\n\nThis callback method works together with walkRecursive() and is called\nfor every file/and or directory. The $context is a callback specific\ncontainer in which data can be stored and shared between the different\ncalls to the callback function. The walkRecursive() function also passes\nin the full absolute directory in $sourceDir, the filename in $fileName\nand file information (such as size, modes, types) as an array as\nreturned by PHP's stat() in the $fileInfo parameter.","scope":"ezcBaseFile","children":[{"kind":128,"name":"$context","location":[74,53,74,84],"scope":"findRecursiveCallback","typeSource":1,"type":"ezcBaseFileFindContext"},{"kind":128,"name":"$sourceDir","location":[74,86,74,96],"scope":"findRecursiveCallback","type":"string"},{"kind":128,"name":"$fileName","location":[74,98,74,107],"scope":"findRecursiveCallback","type":"string"},{"kind":128,"name":"$fileInfo","location":[74,109,74,118],"scope":"findRecursiveCallback","type":"array(stat)"}]},{"kind":32,"name":"walkRecursive","modifiers":33,"location":[129,4,206,5],"description":"Walks files and directories recursively on a file system\n\nThis method walks over a directory and calls a callback from every file\nand directory it finds. You can use $includeFilters to include only\nspecific files, and $excludeFilters to exclude certain files from being\nreturned. The function will always go into subdirectories even if the\nentry would not have passed the filters.\n\nThe callback is passed in the $callback parameter, and the\n$callbackContext will be send to the callback function/method as\nparameter so that you can store data in there that persists with all the\ncalls and recursive calls to this method. It's up to the callback method\nto do something useful with this. The callback function's parameters are\nin order:\n\n<ul>\n<li>ezcBaseFileFindContext $context</li>\n<li>string $sourceDir</li>\n<li>string $fileName</li>\n<li>array(stat) $fileInfo</li>\n</ul>\n\nSee {@see findRecursiveCallback()} for an example of a callback function.\n\nFilters are regular expressions and are therefore required to have\nstarting and ending delimiters. The Perl Compatible syntax is used as\nregular expression language.","scope":"ezcBaseFile","type":"array","children":[{"kind":128,"name":"$sourceDir","location":[129,42,129,52],"scope":"walkRecursive","type":"string"},{"kind":128,"name":"$includeFilters","location":[129,54,129,85],"scope":"walkRecursive","value":"array()","type":"array(string)"},{"kind":128,"name":"$excludeFilters","location":[129,87,129,118],"scope":"walkRecursive","value":"array()","type":"array(string)"},{"kind":128,"name":"$callback","location":[129,120,129,129],"scope":"walkRecursive","type":"callback"},{"kind":128,"name":"$callbackContext","location":[129,131,129,148],"scope":"walkRecursive","type":"mixed"}]},{"kind":32,"name":"findRecursive","modifiers":33,"location":[238,4,258,5],"description":"Finds files recursively on a file system\n\nWith this method you can scan the file system for files. You can use\n$includeFilters to include only specific files, and $excludeFilters to\nexclude certain files from being returned. The function will always go\ninto subdirectories even if the entry would not have passed the filters.\nIt uses the {@see walkRecursive()} method to do the actually recursion.\n\nFilters are regular expressions and are therefore required to have\nstarting and ending delimiters. The Perl Compatible syntax is used as\nregular expression language.\n\nIf you pass an empty array to the $statistics argument, the function\nwill in details about the number of files found into the 'count' array\nelement, and the total filesize in the 'size' array element. Because this\nargument is passed by reference, you *have* to pass a variable and you\ncan not pass a constant value such as \"array()\".","scope":"ezcBaseFile","type":"array","children":[{"kind":128,"name":"$sourceDir","location":[238,42,238,52],"scope":"findRecursive","type":"string"},{"kind":128,"name":"$includeFilters","location":[238,54,238,85],"scope":"findRecursive","value":"array()","type":"array(string)"},{"kind":128,"name":"$excludeFilters","location":[238,87,238,118],"scope":"findRecursive","value":"array()","type":"array(string)"},{"kind":128,"name":"$statistics","location":[238,120,238,139],"scope":"findRecursive","value":"null","type":"array()"}]},{"kind":32,"name":"removeRecursive","modifiers":33,"location":[270,4,310,5],"description":"Removes files and directories recursively from a file system\n\nThis method recursively removes the $directory and all its contents.\nYou should be <b>extremely</b> careful with this method as it has the\npotential to erase everything that the current user has access to.","scope":"ezcBaseFile","children":[{"kind":128,"name":"$directory","location":[270,44,270,54],"scope":"removeRecursive","type":"string"}]},{"kind":32,"name":"copyRecursive","modifiers":33,"location":[336,4,393,5],"description":"Recursively copy a file or directory.\n\nRecursively copy a file or directory in $source to the given\ndestination. If a depth is given, the operation will stop, if the given\nrecursion depth is reached. A depth of -1 means no limit, while a depth\nof 0 means, that only the current file or directory will be copied,\nwithout any recursion.\n\nYou may optionally define modes used to create files and directories.","scope":"ezcBaseFile","type":"void","children":[{"kind":128,"name":"$source","location":[336,42,336,49],"scope":"copyRecursive","type":"string"},{"kind":128,"name":"$destination","location":[336,51,336,63],"scope":"copyRecursive","type":"string"},{"kind":128,"name":"$depth","location":[336,65,336,76],"scope":"copyRecursive","value":"-1","type":"int"},{"kind":128,"name":"$dirMode","location":[336,78,336,93],"scope":"copyRecursive","value":"0775","type":"int"},{"kind":128,"name":"$fileMode","location":[336,95,336,111],"scope":"copyRecursive","value":"0664","type":"int"}]},{"kind":32,"name":"calculateRelativePath","modifiers":33,"location":[408,4,451,5],"description":"Calculates the relative path of the file/directory '$path' to a given\n$base path.\n\n$path and $base should be fully absolute paths. This function returns the\nanswer of \"How do I go from $base to $path\". If the $path and $base are\nthe same path, the function returns '.'. This method does not touch the\nfilesystem.","scope":"ezcBaseFile","type":"string","children":[{"kind":128,"name":"$path","location":[408,50,408,55],"scope":"calculateRelativePath","type":"string"},{"kind":128,"name":"$base","location":[408,57,408,62],"scope":"calculateRelativePath","type":"string"}]},{"kind":32,"name":"isAbsolutePath","modifiers":33,"location":[465,4,509,5],"description":"Returns whether the passed $path is an absolute path, giving the current $os.\n\nWith the $os parameter you can tell this function to use the semantics\nfor a different operating system to determine whether a path is\nabsolute. The $os argument defaults to the OS that the script is running\non.","scope":"ezcBaseFile","type":"bool","children":[{"kind":128,"name":"$path","location":[465,43,465,48],"scope":"isAbsolutePath","type":"string"},{"kind":128,"name":"$os","location":[465,50,465,60],"scope":"isAbsolutePath","value":"null","type":"string"}]}]}]}}